Yafowil common widgets
======================

Trigger registry by importing.
::

    >>> import yafowil.common


Text Input Widget
-----------------
::

    >>> from yafowil.base import factory
    >>> inputwidget = factory('text', name='MYTEXT', value='Test Text')    
    >>> inputwidget()
    u'<input id="input-MYTEXT" name="MYTEXT" type="text" value="Test Text" />'

    >>> inputwidget = factory('password', 'MYPASSWORD', '')
    >>> inputwidget()
    u'<input id="input-MYPASSWORD" name="MYPASSWORD" type="password" value="" />'

    >>> inputwidget = factory('hidden', 'MYHIDDEN', 'Test Hidden')
    >>> inputwidget()
    u'<input id="input-MYHIDDEN" name="MYHIDDEN" type="hidden" value="Test Hidden" />'


Required Input Widget
---------------------

Render required widget.
::

    >>> inputwidget = factory('text', 'REQUIRED', '',
    ...                       {'required': True,
    ...                        'error_class': True})
    >>> inputwidget()
    u'<input class="required" id="input-REQUIRED" name="REQUIRED" type="text" 
    value="" />'

Extract with empty request, key not in request therefore no error.
::
    
    >>> data = inputwidget.extract({})
    >>> data
    <RuntimeData REQUIRED, value='', extracted=<UNSET>, 
    attrs={'input_field_type': 'text'} at ...>
        
Extract with empty input sent, required error expected.
::    
    
    >>> data = inputwidget.extract({'REQUIRED': ''})
    >>> data
    <RuntimeData REQUIRED, value='', extracted='', 1 error(s), 
    attrs={'input_field_type': 'text'} at ...>

    >>> data.errors
    [ExtractionError('Mandatory field was empty',)]

With getter value set, empty request, no error expected.
::    
    
    >>> inputwidget = factory('text', 'REQUIRED', 'Test Text',
    ...                       {'required': True,
    ...                        'error_class': True})
    >>> data = inputwidget.extract({})
    >>> data
    <RuntimeData REQUIRED, value='Test Text', extracted=<UNSET>,
    attrs={'input_field_type': 'text'} at ...>

    >>> inputwidget(data=data)
    u'<input class="required" id="input-REQUIRED" name="REQUIRED" type="text" 
    value="Test Text" />'

With getter value set, request given, error expected.
::    

    >>> data = inputwidget.extract({'REQUIRED': ''})
    >>> data
    <RuntimeData REQUIRED, value='Test Text', extracted='', 1 error(s), 
    attrs={'input_field_type': 'text'} at ...>
    
    >>> inputwidget(data=data)
    u'<input class="error required" id="input-REQUIRED" name="REQUIRED" 
    type="text" value="" />'

Create a custom error message.
::    

    >>> inputwidget = factory('text', 'REQUIRED', '',
    ...                       {'required': 'You fool, fill in a value!'})
    >>> data = inputwidget.extract({})
    >>> data 
    <RuntimeData REQUIRED, value='', extracted=<UNSET>, 
    attrs={'input_field_type': 'text'} at ...>
    

Checkbox Widget
---------------

A boolean checkbox widget (default).
::
    
    >>> inputwidget = factory('checkbox', 'MYCHECKBOX')    
    >>> inputwidget()
    u'<input id="input-MYCHECKBOX" name="MYCHECKBOX" 
    type="checkbox" value="" /><input id="checkboxexists-MYCHECKBOX" 
    name="MYCHECKBOX-exists" type="hidden" value="checkboxexists" />'

    >>> inputwidget = factory('checkbox', 'MYCHECKBOX', value='True')    
    >>> inputwidget()
    u'<input checked="checked" id="input-MYCHECKBOX" name="MYCHECKBOX" 
    type="checkbox" value="" /><input id="checkboxexists-MYCHECKBOX" 
    name="MYCHECKBOX-exists" type="hidden" value="checkboxexists" />'

A checkbox widget with an value or an empty string.
::

    >>> inputwidget = factory('checkbox', 'MYCHECKBOX', '',
    ...                       props={'format': 'string'})    
    >>> inputwidget()
    u'<input id="input-MYCHECKBOX" name="MYCHECKBOX" 
    type="checkbox" value="" /><input id="checkboxexists-MYCHECKBOX" 
    name="MYCHECKBOX-exists" type="hidden" value="checkboxexists" />'

    >>> inputwidget = factory('checkbox', 'MYCHECKBOX', 'Test Checkbox',
    ...                       props={'format': 'string'})    
    >>> inputwidget()
    u'<input checked="checked" id="input-MYCHECKBOX" name="MYCHECKBOX" 
    type="checkbox" value="Test Checkbox" /><input id="checkboxexists-MYCHECKBOX" 
    name="MYCHECKBOX-exists" type="hidden" value="checkboxexists" />'


Textarea Widget
---------------
::

    >>> inputwidget = factory('textarea', 'MYTEXTAREA', 'Test Textarea',
    ...                       dict(label='Test Textarea Widget',
    ...                            css={'input': 'inputcss', 
    ...                                 'label': 'labelcss'},
    ...                            id={'label': 'TestLabelId'}))
    >>> inputwidget()
    u'<textarea cols="80" id="input-MYTEXTAREA" name="MYTEXTAREA" rows="25">Test Textarea</textarea>'


Selection Widget
----------------
::

    >>> selectwidget = factory('select', 'MYSELECT', ['one', 'three'],
    ...                       {'vocabulary': [('one','One'), 
    ...                                       ('two', 'Two'), 
    ...                                       ('three', 'Three'),
    ...                                       ('four', 'Four')],
    ...                       })
    >>> selectwidget()
    u'<select id="input-MYSELECT" name="MYSELECT"><option id="input-MYSELECT-one" 
    selected="selected" value="one">One</option><option id="input-MYSELECT-two" 
    value="two">Two</option><option id="input-MYSELECT-three" selected="selected" 
    value="three">Three</option><option id="input-MYSELECT-four" 
    value="four">Four</option></select>'

    >>> data = selectwidget.extract({'MYSELECT': 'two'})
    >>> selectwidget(data=data)
    u'<select id="input-MYSELECT" name="MYSELECT"><option id="input-MYSELECT-one" 
    value="one">One</option><option id="input-MYSELECT-two" selected="selected" 
    value="two">Two</option><option id="input-MYSELECT-three" 
    value="three">Three</option><option id="input-MYSELECT-four" 
    value="four">Four</option></select>'
    
    >>> selectwidget = factory('select', 'MYSELECT', ['one', 'three'],
    ...                       {'vocabulary': [('one','One'), 
    ...                                       ('two', 'Two'), 
    ...                                       ('three', 'Three'),
    ...                                       ('four', 'Four')],
    ...                        'format': 'single',
    ...                       })
    >>> selectwidget()
    u'<input id="exists-MYSELECT" name="MYSELECT-exists" type="hidden" 
    value="exists" /><div id="radio-MYSELECT-one"><input checked="checked" 
    id="input-MYSELECT-one" name="MYSELECT" type="radio" value="one" 
    /><span>One</span></div><div id="radio-MYSELECT-two"><input 
    id="input-MYSELECT-two" name="MYSELECT" type="radio" value="two" 
    /><span>Two</span></div><div id="radio-MYSELECT-three"><input 
    checked="checked" id="input-MYSELECT-three" name="MYSELECT" type="radio" 
    value="three" /><span>Three</span></div><div id="radio-MYSELECT-four"><input 
    id="input-MYSELECT-four" name="MYSELECT" type="radio" value="four" 
    /><span>Four</span></div>'

    
File Widget
-----------

    >>> widget = factory('file', 'MYFILE')
    >>> widget()
    u'<input id="input-MYFILE" name="MYFILE" type="file" value="" />'
    
    >>> widget = factory('file', 'MYFILE', value='x')
    >>> widget()
    u'<input id="input-MYFILE" name="MYFILE" type="file" value="" /><div 
    id="radio-MYFILE-keep"><input checked="checked" id="input-MYFILE-keep" 
    name="MYFILE-action" type="radio" value="keep" /><span>Keep Existing 
    file</span></div><div id="radio-MYFILE-replace"><input 
    id="input-MYFILE-replace" name="MYFILE-action" type="radio" 
    value="replace" /><span>Replace existing file</span></div><div 
    id="radio-MYFILE-delete"><input id="input-MYFILE-delete" 
    name="MYFILE-action" type="radio" value="delete" /><span>Delete 
    existing file</span></div>'    
    
    >>> request = {
    ...     'MYFILE': 'y',
    ...     'MYFILE-action': 'keep'
    ... }
    >>> data = widget.extract(request)
    >>> data.extracted
    'x'
    
    >>> request['MYFILE-action'] = 'replace'
    >>> data = widget.extract(request)
    >>> data.extracted
    'y'
    
    >>> request['MYFILE-action'] = 'delete'
    >>> data = widget.extract(request)
    >>> data.extracted
    <UNSET>


Submit Widget (action)
----------------------
::

    >>> props = {
    ...     'action': True,
    ...     'label': 'Action name',
    ... }
    >>> widget = factory('submit', name='save', props=props)
    >>> widget()
    u'<input id="input-save" name="action.save" type="submit" value="Action name" />'


Proxy Widget
------------

Used to pass hidden arguments out of form namespace.
::

    >>> widget = factory('proxy', name='proxy', value='1')
    >>> widget()
    u'<input id="input-proxy" name="proxy" type="hidden" value="1" />'


Label Widget
------------

Default.
::

    >>> widget = factory('label:file', name='MYFILE', \
    ...                   props={'label': 'MY FILE'})
    >>> widget()
    u'<label for="input-MYFILE">MY FILE</label><input id="input-MYFILE" 
    name="MYFILE" type="file" value="" />'
    
Label after widget.
::

    >>> widget = factory('label:file', name='MYFILE', \
    ...                   props={'label': 'MY FILE',
    ...                          'label.position': 'after'})
    >>> widget()
    u'<input id="input-MYFILE" name="MYFILE" type="file" value="" /><label 
    for="input-MYFILE">MY FILE</label>'
    
Same with inner label.
::

    >>> widget = factory('label:file', name='MYFILE', \
    ...                   props={'label': 'MY FILE',
    ...                          'label.position': 'inner'})
    >>> widget()
    u'<label for="input-MYFILE">MY FILE<input id="input-MYFILE" 
    name="MYFILE" type="file" value="" /></label>'
    

Field Widget
------------
    
Chained file inside field with label.
::

    >>> widget = factory('field:label:file', name='MYFILE', \
    ...                   props={'label': 'MY FILE'})
    >>> widget()
    u'<div class="field" id="field-MYFILE"><label 
    for="input-MYFILE">MY FILE</label><input id="input-MYFILE" 
    name="MYFILE" type="file" value="" /></div>'


Error Widget
------------

Chained password inside error inside field.
::

    >>> widget = factory('field:error:password', name='password',
    ...                  props={'label': 'Password',
    ...                         'required': 'No password given!'})
    
    >>> data = widget.extract({'password': ''}) 
    >>> widget(data=data)
    u'<div class="field" id="field-password"><div class="error"><div 
    class="errormessage">No password given!</div><input class="required" 
    id="input-password" name="password" type="password" value="" /></div></div>'
    
    >>> data = widget.extract({'password': 'secret'})
    >>> widget(data=data)
    u'<div class="field" id="field-password"><input class="required" 
    id="input-password" name="password" type="password" value="secret" /></div>'


View Widget
-----------

I is a very common task to decide if a widget should be rendered as is, should
only be displayed or even completly hidden.

You could solve this in two ways. The first way is to use the custom chain
mechanism.

Define custom renderer.
::

    >>> def hideordisplay(widget, data):
    ...     if data.request.get('hide'):
    ...         return ''
    ...     if data.request.get('display'):
    ...         return '<div>' + data.value + '</div>'
    ...     return data.rendered

Hook custom to chain on widget generation.
::

    >>> widget = factory(
    ...     '*hideordisplay:field:label:text',
    ...     'foo',
    ...     value = 'foo',
    ...     props = {
    ...         'label': 'Foo',
    ...     },
    ...     custom = {
    ...         'hideordisplay': ([], [hideordisplay], [], []),
    ...     })

Check results.
::

    >>> widget(request={})
    u'<div class="field" id="field-foo"><label 
    for="input-foo">Foo</label><input id="input-foo" name="foo" type="text" 
    value="foo" /></div>'
    
    >>> widget(request={'display': True})
    '<div>foo</div>'
    
    >>> widget(request={'hide': True})
    ''

So what happend in the above example, is to just break the chain on
inappropriate permissions by ignoring the renderd widget and return anything
else (note the whole chain runs anyway).

It seem a little odd (at least to me [rnix]) to always rewrite this stub work
elsewhere. The code grows, and the coder gets bored by unnecessary code
repeation and even more debugging by copy and paste errors.

The second way is to use the registered 'view' widget. Basically its constrolled
by the 'mode' property and tries to render data.value decided on type.
::

Dummy mode decider function.
::

    >>> def modedecider(widget, data):
    ...     mode = data.request.get('mode')
    ...     if mode == 'view': return 'view'
    ...     if mode == 'hidden': return 'hidden'
    ...     return 'edit'

Test view widget with singlevalue.
::

    >>> widget = factory(
    ...     'view:field:label:text',
    ...     'foo',
    ...     value = 'foo',
    ...     props = {
    ...         'label': 'Foo',
    ...         'mode': modedecider,
    ...     })
    
    >>> widget(request={'mode': 'edit'})
    u'<div class="field" id="field-foo"><label 
    for="input-foo">Foo</label><input id="input-foo" name="foo" type="text" 
    value="foo" /></div>'
    
    >>> widget(request={'mode': 'view'})
    u'<div>foo</div>'
    
    >>> widget(request={'mode': 'hidden'})
    u''

Test view widget with iterable value.
::

    >>> widget = factory(
    ...     'view:field:label:select',
    ...     'foo',
    ...     value = ['foo', 'bar'],
    ...     props = {
    ...         'label': 'Foo',
    ...         'mode': modedecider,
    ...     })
    
    >>> widget(request={'mode': 'view'})
    u'<ul><li>foo</li><li>bar</li></ul>'

Finally you might want to use your own renderer. You can define this with
'view.alternative' property. Just define a callback function doing the rendering
job.

The controverse is now that some might say this breaks the concept since it
acts a little like a dispatcher, and for rendering hooks at al the custom
property is intended.

But, the custom hook above does exactly the same dispatching...

...and ...

...what else should a 'view' widget do than check permissions and render
something?

So i think there is good reason to make it possible by widget contract to
overwrite the renderer via widget props - remember - we have here a widget
witch is intended to render something...

Decide on your own if you prefer the 'clean' or the 'convenient' way of doing
(recurring) tasks.

    >>> def alternative_renderer(widget, data):
    ...     return u'<p>alternative</p>'

    >>> widget = factory(
    ...     'view:field:label:text',
    ...     'foo',
    ...     value = 'foo',
    ...     props = {
    ...         'label.label': 'Foo',
    ...         'view.mode': modedecider,
    ...         'view.alternative': alternative_renderer,
    ...     })
    
    >>> widget(request={'mode': 'edit'})
    u'<div class="field" id="field-foo"><label 
    for="input-foo">Foo</label><input id="input-foo" name="foo" type="text" 
    value="foo" /></div>'
    
    >>> widget(request={'mode': 'view'})
    u'<p>alternative</p>'
    
    >>> widget(request={'mode': 'hidden'})
    u''