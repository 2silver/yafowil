Test UNSET
==========
::

    >>> from yafowil.base import UNSET
    >>> UNSET
    <UNSET>
    
    >>> str(UNSET)
    ''

    >>> bool(UNSET)
    False

Test Runtime Data
=================
::    

    >>> from yafowil.base import RuntimeData
    >>> data = RuntimeData()
    >>> sorted(data.keys())
    ['errors', 'extracted', 'rendered']
    
    >>> data['custom'] = 'customdata'
    >>> data
    {'custom': 'customdata', 'errors': [], 'extracted': [], 'rendered': []}
    
    >>> data.last_extracted
    <UNSET>
    
    >>> data.has_extracted
    False

    >>> data['extracted'].append(dict())
    >>> data.has_extracted
    False

    >>> data['extracted'].append(dict(key='value'))
    >>> data.has_extracted
    True

    >>> data['extracted'].append(dict(key='value', key2=RuntimeData()))
    >>> data.has_extracted
    Traceback (most recent call last):
    ...
    ValueError

    >>> data['extracted'].append(dict(key=RuntimeData()))
    >>> data.has_extracted
    False

    >>> subdata = RuntimeData()
    >>> subdata['extracted'].append('subvalue')
    >>> data['extracted'].append(dict(key=subdata))
    >>> data.has_extracted
    True
        
    >>> data.last_rendered
    u''
    
    >>> data['extracted'].append('first')    
    >>> data['extracted'].append('second')    
    >>> data['extracted'].append('last')    
    >>> data.last_extracted
    'last'    

    >>> data['rendered'].append('first')    
    >>> data['rendered'].append('second')    
    >>> data['rendered'].append('last')    
    >>> data.last_rendered
    'last'
        
Test Base Widget
================
::

    >>> from yafowil.base import Widget
    >>> from yafowil.base import ExtractionError 
    
Create some test dummies::

    >>> def test_extractor(widget, data):
    ...     return 'e1'

    >>> def test_extractor2(widget, data):
    ...     return 'e2'

    >>> def test_extractor3(widget, data):
    ...     try:
    ...         return int(data['value'])
    ...     except:
    ...         raise ExtractionError('e3: Integer expected, got %s' % \
    ...                               data['value'])
    ...     return value
    
    >>> def test_renderer(widget, data):
    ...     return 'r1', widget.__name__, str(data), str(widget.attributes)

    >>> def test_renderer2(widget, data):
    ...     return 'r2', widget.__name__, str(data), str(widget.attributes)
    
    >>> def test_preprocessor(widget, data):
    ...     data['test_preprocessor'] = 'called'
    ...     return data
    
    >>> def test_getter(widget, data):
    ...     return 'Test Value'

    >>> def test_getter2(widget, data):
    ...     return 123

Test the base widget class::    
    
    >>> test_request = {'MYUID': 'New Test Value'}
    >>> testwidget = Widget([test_extractor], 
    ...                     [test_renderer], 
    ...                     [test_preprocessor],
    ...                     'MYUID', test_getter,
    ...                     dict(test1='Test1', test2='Test2'))
        
    >>> testwidget() 
    ('r1', 'MYUID', "{'errors': [], 'extracted': [], 'rendered': [], 'request': 
    {}, 'test_preprocessor': 'called', 'value': 'Test Value'}", "{'test1': 
    'Test1', 'test2': 'Test2'}")

    >>> testwidget(request=test_request) 
    ('r1', 'MYUID', "{'errors': [], 'extracted': ['e1'], 'rendered': [], 'request': 
    {'MYUID': 'New Test Value'}, 'test_preprocessor': 'called', 'value': 
    'Test Value'}", "{'test1': 'Test1', 'test2': 'Test2'}")
    
    >>> testwidget.extract(test_request)
    {'errors': [], 'extracted': ['e1'], 'rendered': [], 'request': {'MYUID': 
    'New Test Value'}, 'test_preprocessor': 'called', 'value': 'Test Value'}
    
    >>> testwidget = Widget([test_extractor], 
    ...                     [test_renderer], 
    ...                     [],
    ...                     'MYUID', test_getter,
    ...                     dict(test1='Test1', test2='Test2'))    
    >>> testwidget()
    ('r1', 'MYUID', "{'errors': [], 'extracted': [], 
    'rendered': [], 'request': {}, 'value': 'Test Value'}", "{'test1': 'Test1', 
    'test2': 'Test2'}")
    
    >>> testwidget = Widget([test_extractor, test_extractor2], 
    ...                     [test_renderer, test_renderer2], 
    ...                     [],
    ...                     'MYUID2', test_getter,
    ...                     dict(test1='Test1', test2='Test2'))
    >>> testwidget()
    ('r2', 'MYUID2', '{\'errors\': [], \'extracted\': [], \'rendered\': 
    [(\'r1\', \'MYUID2\', "{\'errors\': [], \'extracted\': [], \'rendered\': [], 
    \'request\': {}, \'value\': \'Test Value\'}", "{\'test1\': \'Test1\', \'test2\': 
    \'Test2\'}")], \'request\': {}, \'value\': \'Test Value\'}', "{'test1': 'Test1', 
    'test2': 'Test2'}")

    >>> testwidget = Widget([test_extractor3], 
    ...                     [test_renderer], 
    ...                     [],
    ...                     'MYUID2', test_getter,
    ...                     dict(test1='Test1', test2='Test2'))

    >>> testwidget.extract({})
    {'errors': [ExtractionError('e3: Integer expected, got Test Value',)], 
    'extracted': [], 'rendered': [], 'request': {}, 'value': 'Test Value'}
    
    >>> testwidget = Widget([test_extractor3], 
    ...                     [test_renderer], 
    ...                     [],
    ...                     'MYUID2', test_getter2,
    ...                     dict(test1='Test1', test2='Test2'))

    >>> testwidget.extract({})
    {'errors': [], 'extracted': [123], 'rendered': [], 'request': {}, 'value': 123}

        
Test the factory
================
::
    >>> from yafowil.base import Factory
    >>> factory = Factory()
    >>> factory.register('widget_test', [test_extractor], [test_renderer])
    >>> factory.extractors('widget_test')
    [<function test_extractor at ...>]
    
    >>> factory.renderers('widget_test')
    [<function test_renderer at ...>]
    
    >>> testwidget = factory('widget_test', 'MYFAC', test_getter, 
    ...                      dict(foo='bar'))
    >>> testwidget()
    ('r1', 'MYFAC', "{'errors': [], 'extracted': [], 'rendered': [], 'request': 
    {}, 'value': 'Test Value'}", "{'foo': 'bar'}")
    
We can create sets of static subwidgets, i.e. to have a validating password
field with two input fields in. Here a simpler example:: 

    >>> def create_static_compound(widget, factory):
    ...     widget['one'] = factory('widget_test', widget.attrs)
    ...     widget['two'] = factory('widget_test', widget.attrs)
        
    >>> factory.register('static_compound', [], [], 
    ...                  subwidgets=[create_static_compound])
    
    >>> widget = factory('static_compound', {})
    >>> widget.keys()
    ['one', 'two']
        
request chains via factory
--------------------------

Sometimes we want to wrap inputs by UI candy, primary for usability reasons. 
This might be a label, some error output or div around. We dont want to register
an amount of X possible widgets with an amount of Y possible wrappers. Therefore
we can factor a widget in a chain defined colon-separated, i.e 'outer:inner' or 
'field:error:text'. Chaining works for all parts: renderers, extractors, 
preprocessors and subwidgets. Most inner and first executed is right (we prefix 
with wrappers)!
::

    >>> def inner_renderer(widget, data):
    ...     return u'<INNER />'

    >>> def inner_extractor(widget, data):
    ...     return ['extracted inner']

    >>> def outer_renderer(widget, data):
    ...     return u'<OUTER>%s</OUTER>' % data.last_rendered
    
    >>> def outer_extractor(widget, data):
    ...     return data.last_extracted + ['extracted outer']
        
    >>> factory.register('inner', [inner_extractor], [inner_renderer])
    >>> factory.register('outer', [outer_extractor], [outer_renderer])
    >>> widget = factory('outer:inner')
    >>> data = widget.extract({})
    >>> data.last_extracted
    ['extracted inner', 'extracted outer']
    
    >>> widget(data)
    u'<OUTER><INNER /></OUTER>'
    
    
    